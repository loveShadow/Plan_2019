# 第一个Jni程序
---
### 实现目标  
>> * 通过java程序调用C++实现的算法接口[加法算法]  
>> * 通过C++调用android自带的接口[打印日志][显示结果]  
>> * 通过C++调用java程序自己实现的接口[获取倍率]  

### 实现效果
>> 1. 调用C++接口计算两个数的和，并打印到日志中  
>> 2. C++调用android的接口显示计算结果  
>> 3. 调用C++接口计算乘法，给出一个乘数，C++从Android接口获取倍率并计算结果  

最终实现项目地址
https://github.com/loveShadow/Study_NDK_Sample_1

### 实现过程

#### 第一步：创建Jni类并编写native方法，如下：

```Java
public class NDKDemo {
    /**
    * 求和算法
    * @param arg1 参数1
    * @param arg2 参数2
    * @return 和
    */
    public static native int sum(int arg1, int arg2);
}
```
#### 第二步：执行命令生成方法对应的头文件

   **命令如下：**

>>G:\xxx\Study_NDK_Sample_1\app\src\main\java>`javah -d ../jni com.study.ndk.NDKDemo`  

   **遇到的问题：**

   **问题一：** 报错（错误: 编码GBK的不可映射字符）
   ![编码问题](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/ndk_encode_error.png "编码问题")   
   问题原因：java文件是UTF-8格式的  
   解决办法：使用如下命令：

>>G:\xxx\Study_NDK_Sample_1\app\src\main\java>javah -d ../jni -encoding UTF-8 com.study.ndk.NDKDemo

   **生成的头文件示例：**
```C++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_study_ndk_NDKDemo */

#ifndef _Included_com_study_ndk_NDKDemo
#define _Included_com_study_ndk_NDKDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
* Class:    com_study_ndk_NDKDemo
* Method:    sum
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_com_study_ndk_NDKDemo_sum
  (JNIEnv *, jclass, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```
#### 第三步：编写C/C++代码

>>步骤：右键jni目录---->new--->C/C++ Source File

 ![生成C++文件](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/ndk_new_c%2B%2B.png "生成C++文件")    

**此时发现没有代码提示**

**`解决办法一（非唯一解决办法）：`**

* 第一步：创建项目时需要选择如下：  
  ![创建项目](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/ndk_new_application.png "创建项目") 
* 第二步：  
  ![创建项目2](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/ndk_new_application_2.png "创建项目2") 

**题外：C++ RTTI 简介**
>>RTTI是Runtime Type Identification的缩写，即运行时类型识别。程序能够借此使用基类的指针或引用，来检查这些指针或引用所指的对象的实际派生类型。C++通过typeid与dynamic_cast来提供RTTI。typeid返回一个typeinfo对象的引用，它记录了与类型相关的信息，后文将详细分析这个结构；dynamic_cast用于安全而有效地进行向下转型(down_cast)，即安全地将一个基类指针转换为一个派生类指针。

**遇到的问题：**

* 问题一： Error:Unable to get the CMake version located at: E:\Android\AndroidSDK\cmake\bin
          找不到CMake的位置。
  ![找不到CMake的位置](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/cmake_error.png "找不到CMake的位置")   
          解决办法：下载安装SDK Tools 里面的CMake
  ![解决办法](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/install_cmake.png "解决办法") 

* 问题二：CMake Error: Could not create named generator Android Gradle - Ninja Generators
  ![CMake Error 2](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/cmake_error_2.png "CMake Error 2")   
         解决办法：安装3.6.4111459版本
  ![CMake 安装](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/install_cmake_details.png "CMake 安装")   
  ![CMake 安装](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/install_cmake_details_2.png "CMake 安装")   
   解决代码自动提示问题后，继续编写C/C++代码
   
#### 第四步：实现加法功能

  java中的int和C++中的int是一致的，所以可以直接返回
```C++
#include "com_study_ndk_NDKDemo.h"
#include <jni.h>

JNIEXPORT jint JNICALL Java_com_study_ndk_NDKDemo_sum
        (JNIEnv * env, jclass jc, jint arg1, jint arg2) {
    /**
    * 计算结果
    */
    jint result = arg1 + arg2;

    /**
    * 调用Android的logcat进行打印
    */
    return result;
}
```
#### 第五步：实现调用Android的Log功能

  Jni中Logcat的日志输出在log.h中定义
```C++
#include "com_study_ndk_NDKDemo.h"
#include <jni.h>
#include <android/log.h>

/**
* 导入Android Log 的.h文件及定义宏
*/
#define LOG_TAG "libSum"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

JNIEXPORT jint JNICALL Java_com_study_ndk_NDKDemo_sum
        (JNIEnv * env, jclass jc, jint arg1, jint arg2) {
    /**
    * 计算结果
    */
    jint result = arg1 + arg2;

    /**
    * 调用Android的logcat进行打印
    */
    LOGI("sum | arg1 = %d, arg2 = %d, result = %d", arg1, arg2, result);
    return result;
}
```

#### 第五步：修改CMakeList.txt

```
# For more information about using CMake with Android Studio, read the
# documentation: https://d.android.com/studio/projects/add-native-code.html

# Sets the minimum version of CMake required to build the native library.

# 指定需要CMake的最小版本
cmake_minimum_required(VERSION 3.4.1)

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds them for you.
# Gradle automatically packages shared libraries with your APK.

# 设置生成so动态库最后输出的路径 [指定abi在build.gradle中]
# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI})

add_library( # 设置so的名称.
            sum

            # 设置so为共享库.
            SHARED

            # 设置C/C++文件源码位置
            src/main/cpp/NDKSum.cpp )

# Searches for a specified prebuilt library and stores the path as a
# variable. Because CMake includes system libraries in the search path by
# default, you only need to specify the name of the public NDK library
# you want to add. CMake verifies that the library exists before
# completing its build.

find_library( # Sets the name of the path variable.
              log-lib

              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )

# Specifies libraries CMake should link to your target library. You
# can link multiple libraries, such as libraries you define in this
# build script, prebuilt third-party libraries, or system libraries.

target_link_libraries( # 连接我们自己生成的库.
                      sum

                      # Links the target library to the log library
                      # included in the NDK.
                      ${log-lib} )
```

#### 第六步：修改build.gradle

```Java
defaultConfig {
    applicationId "com.study.ndk"
    minSdkVersion 17
    targetSdkVersion 26
    versionCode 1
    versionName "1.0"
    externalNativeBuild {
        /**
        * cmake的相关配置
        * 同创建项目时设置的东西
        */
        cmake {
            cppFlags "-frtti -fexceptions"
        }

        /**
        * 设置ndk构建只生成armeabi的so库
        */
        ndk {
            abiFilters 'armeabi'
        }
    }
}

buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
}

externalNativeBuild {
    cmake {
        path "CMakeLists.txt"
    }
}
```

#### 第七步：第一阶段成果验证
  ![第一阶段成果](https://github.com/loveShadow/Plan_2019/blob/master/1.%20ndk/images/part_result_1.png "第一阶段成果") 

#### 第八步：所有代码
```C++
#include "com_study_ndk_NDKDemo.h"
#include <jni.h>
#include <android/log.h>

/**
 * 导入Android Log 的.h文件及定义宏
 */
#define LOG_TAG "libSum"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)


JNIEXPORT jint JNICALL Java_com_study_ndk_NDKDemo_sum
        (JNIEnv * env, jclass jc, jint arg1, jint arg2) {
    /**
     * 计算结果
     */
    jint result = arg1 + arg2;

    /**
     * 调用Android的logcat进行打印
     */
    LOGI("sum | arg1 = %d, arg2 = %d, result = %d", arg1, arg2, result);
    return result;
}

JNIEXPORT jint JNICALL Java_com_study_ndk_NDKDemo_mult
        (JNIEnv * env, jclass jc, jint arg1) {
    /**
     * 找到要调用的类
     */
    jclass javaClass = env->FindClass("com/study/ndk/JavaClass");
    /**
     * 判断是否为空指针
     */
    if (nullptr == javaClass) {
        LOGE(LOG_TAG, "cannot find JavaClass");
        return -1;
    }

    /**
     * 获取构造方法
     */
    jmethodID initMethod = env->GetMethodID(javaClass, "<init>", "()V");
    if (nullptr == initMethod) {
        LOGE(LOG_TAG, "cannot find init");
        return -1;
    }

    /**
     * 构造对象
     */
    jobject object = env->NewObject(javaClass, initMethod);
    if (nullptr == object) {
        LOGE(LOG_TAG, "cannot create object");
        return -1;
    }

    /**
     * 找到要调用的方法
     * 第一个：Java类对象
     * 第二个：方法名
     * 第三个：该方法的签名[例如：参数是int类型，返回值void，则签名是(I)V]
     */
    jmethodID methodID = env->GetMethodID(javaClass, "getMultiplier", "()I");
    if (nullptr == methodID) {
        LOGE(LOG_TAG, "cannot find getMultiplier");
        return -1;
    }

    jint arg2 = env->CallIntMethod(object, methodID);
    LOGI(LOG_TAG, "get arg2 = %d", arg2);

    int result = arg1 * arg2;
    return result;
}
```
